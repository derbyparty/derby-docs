## Model Api

After creating bare project change /lib/app/index.js to:

```
app.get('/', function (page, model) {
  model.subscribe('todos', function (err) {
    if (!model.get('todos')) {
      model.add('todos', {text: 'Todo 1' });
      model.add('todos', {text: 'Todo 2' });
    }
    page.render();
  });
});
```

We just subscribed to whole 'todos' collection. In the future, all of our data manipulation we be done only after we subscribe Model to some data, because before it Model is empty. Then we added a couple of documents to collection if collection is not exist.  
model.add - is a wrapper over model.set. The only thing that it does is generate the id itself. We could write:

```
var id = model.id(); // this way guid is generated by using require('node-uuid').v4()
model.set('todos.' + id, {id: id, text: 'Todo 1' });
```

Our collection stored in Model as js-object. If you will do model.get('todos'), you get:

```
{
  "e1b8075c-de9a-458a-aa3c-e9b383691521":
    {
      "text": "Todo 1",
      "id": "e1b8075c-de9a-458a-aa3c-e9b383691521"
    },
  "26cd5f4a-c503-4c25-aeeb-a28c8c034d08":
    {
      "text": "Todo 2",
      "id": "26cd5f4a-c503-4c25-aeeb-a28c8c034d08"
    }
}
```

This format (js-object, hash) is good if we want to get documents by id:

```
var todo = model.get('todos.e1b8075c-de9a-458a-aa3c-e9b383691521');
```

But if we want to show list of todos, it`s better to have an array. We can use Filter for this:

```
app.get('/', function (page, model) {
  model.subscribe('todos', function (err) {
    if (!model.get('todos')) {
      model.add('todos', {text: 'Todo 1' });
      model.add('todos', {text: 'Todo 2' });
    }

    var filter = model.filter('todos');
    filter.ref('_page.todos');

    page.render();
  });
});
```

/views/app/index.html

```
<Body:>
  {#each _page.todos as :todo}
    <p>{:todo.text}</p>
  {/}
```

Here we create a Filter for todos. It monitors changes to the collection and puts result as array into path '_page.todos' using refList, which will be covered later. But the Filter would not be a Filter , if it not be able to filter. We can do like this:

```
var todosFilteredArray = model.filter('todos', function (todo) {
    return todo.text === 'Todo 1';
}).get();
```

Here we have filtered array immediately. Same as Filter, there is Sort. You can use them separately or together:

```
var todosSortedArray = model.filter('todos').sort(function(a, b) {
  return a.text - b.text;
}).get();
```

Here we have array sorted by 'text' field.  
Neither Filter, nor Sort knows nothing about your database. They operate only on data that is in the Model. Fill out Model before use them!

What`s with refList? This is references. It allows you to bind data between two paths. Using them directly needed in rarely cases, but they are used internally by Filter and Queries.

```
app.get('/', function (page, model) {
  model.subscribe('todos', function (err) {
    if (!model.get('todos')) {
      model.add('todos', {text: 'Todo 1' });
      model.add('todos', {text: 'Todo 2' });
    }
    
    var ids = Object.keys(model.get('todos'));
    model.set('_page.ids', ids)
    model.refList('_page.todos', 'todos', '_page.ids');

    page.render();
  });
});
```

ids - a list of ids of those todos, we want to have in result. They also set the order of the array in '_page.todos'. We can change '_page.ids' and it is immediately reflected on the '_page.todos'.

Let play with subscribe:

```
model.subscribe('todos', function (err) {
    // Subscribe to the entire collection of todos
});
model.subscribe('todos.e1b8075c-de9a-458a-aa3c-e9b383691521', function (err) {
    // Subscribe to one document
});
model.subscribe('todos.e1b8075c-de9a-458a-aa3c-e9b383691521.text', function (err) {
    // Subscribed to one field of one document
});
model.subscribe('users', 'todos.e1b8075c-de9a-458a-aa3c-e9b383691521.text', function (err) {
    // You can combine to not produce extra callbacks
});
```

Lets suppose we are very busy people and we have a million todos. And we want to subscribe to only those whose text contains certain characters. Why do we need to upload entire collection to the client? Paths and Filter will not help us in this sutiation. It`s time for Queries:

```
app.get ('/', function (page, model) {
  var query = model.query('todos', {text: 'Todo 1'});
  model.subscribe(query, function (err) {
    if (!model.get('todos')) {
      model.add('todos', {text: 'Todo 1' });
      model.add('todos', {text: 'Todo 2' });
    }

    query.ref('_page.todos');

    page.render();
  });
});
```

Here we create Query, subscribe Model to it and puts results as array to '_page.todos'.  
{text: 'Todo 1'} - is Mongo Queries. livedb-mongo adapter transfers this object directly to Mongo. For other databases, you can write your own adapters and make it different way.
